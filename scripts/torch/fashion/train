#!/usr/bin/env -S uv run --script
# /// script
# dependencies = [
#   "click",
#   "torch",
#   "torchvision",
# ]
# ///

import click
import torch
import torch.utils.data
import torchvision
import torchvision.transforms

from model import FashionNeuralNetwork, test, train

@click.group()
def cli():
    pass


@click.command()
@click.option(
    "--epochs",
    default=10,
    required=False,
    type=int,
    help="number of training epochs",
)
@click.option(
    "--output",
    "output_path",
    default="./data/fashion.model.pth",
    required=False,
    type=str,
    help="model output path",
)
def run(epochs: int, output_path: str) -> dict:
    """ """
    print_status(f"torch train epochs {epochs}")

    # download training data from open datasets
    train_data = torchvision.datasets.FashionMNIST(
        root="./data",
        train=True,
        download=True,
        transform=torchvision.transforms.ToTensor(),
    )

    # download test data from open datasets.
    test_data = torchvision.datasets.FashionMNIST(
        root="./data",
        train=False,
        download=True,
        transform=torchvision.transforms.ToTensor(),
    )

    batch_size = 64

    # create data loaders
    train_dataloader = torch.utils.data.DataLoader(train_data, batch_size=batch_size)
    test_dataloader = torch.utils.data.DataLoader(test_data, batch_size=batch_size)

    print_status("torch data shape:")
    for x, y in test_dataloader:
        print(f"Shape of x [N, C, H, W]: {x.shape}")
        print(f"Shape of y: {y.shape} {y.dtype}")
        break

    device = torch_device()
    model = FashionNeuralNetwork().to(device)

    print_status(f"torch device '{device}' model:")
    print(model)

    loss_fn = torch.nn.CrossEntropyLoss()
    optimizer = torch.optim.SGD(model.parameters(), lr=1e-3)

    print_status("torch train/test loop starting ...")

    for t in range(epochs):
        print(f"epoch {t+1}\n-------------------------------")
        train(train_dataloader, model, loss_fn, optimizer, device)
        test(test_dataloader, model, loss_fn, device)

    torch.save(model.state_dict(), output_path)
    print_ok(f"torch saved model weights to '{output_path}'")


def print_error(s: str):
    print("\x1b[1;31m" + s + "\x1b[0m")


def print_ok(s: str):
    print("\x1b[1;32m" + s + "\x1b[0m")


def print_status(s: str):
    print("\x1b[1;33m" + s + "\x1b[0m")


def torch_device() -> str:
    """
    return supported pytorch device on this machine, should be one of 'cpu', 'mps', 'cuda'
    """
    if torch.cuda.is_available():
        return "cuda"

    if torch.backends.mps.is_available():
        return "mps"

    return "cpu"

# cli.add_command(run)

if __name__ == "__main__":
    run()
