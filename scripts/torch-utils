#!/usr/bin/env -S uv run --script
# /// script
# dependencies = [
#   "click",
#   "torch",
#   "torchvision",
# ]
# ///

import os
import sys

sys.path.insert(1, os.path.join(sys.path[0], ".."))

import click
import torch
import torch.utils.data
import torchvision
import torchvision.transforms

import services.console
import services.torch
import services.torch.fashion


@click.group()
def cli():
    pass


@click.command()
@click.option(
    "--load-path",
    default="./data/fashion.model.pth",
    required=False,
    type=str,
    help="model weights to load",
)
def infer(load_path: str) -> dict:
    """ """
    services.console.print_status(f"torch infer loading from '{load_path}'")

    classes = [
        "T-shirt/top",
        "Trouser",
        "Pullover",
        "Dress",
        "Coat",
        "Sandal",
        "Shirt",
        "Sneaker",
        "Bag",
        "Ankle boot",
    ]

    device = services.torch.torch_device()
    model = services.torch.fashion.FashionNeuralNetwork().to(device)
    model.load_state_dict(torch.load(load_path, weights_only=True))
    model.eval()

    services.console.print_status(f"torch device '{device}' model:")
    print(model)

    test_data = torchvision.datasets.FashionMNIST(
        root="./data",
        train=False,
        download=True,
        transform=torchvision.transforms.ToTensor(),
    )

    x, y = test_data[0][0], test_data[0][1]

    with torch.no_grad():
        x = x.to(device)
        pred = model(x)
        predicted, actual = classes[pred[0].argmax(0)], classes[y]
        print(f'predicted: "{predicted}", actual: "{actual}"')

@click.command()
@click.option(
    "--epochs",
    default=None,
    required=True,
    type=int,
    help="number of training epochs",
)
def train(epochs: int) -> dict:
    """ """
    services.console.print_status(f"torch train epochs {epochs}")

    # download training data from open datasets
    train_data = torchvision.datasets.FashionMNIST(
        root="./data",
        train=True,
        download=True,
        transform=torchvision.transforms.ToTensor(),
    )

    # download test data from open datasets.
    test_data = torchvision.datasets.FashionMNIST(
        root="./data",
        train=False,
        download=True,
        transform=torchvision.transforms.ToTensor(),
    )

    batch_size = 64

    # create data loaders
    train_dataloader = torch.utils.data.DataLoader(train_data, batch_size=batch_size)
    test_dataloader = torch.utils.data.DataLoader(test_data, batch_size=batch_size)

    services.console.print_status("torch data shape:")
    for x, y in test_dataloader:
        print(f"Shape of x [N, C, H, W]: {x.shape}")
        print(f"Shape of y: {y.shape} {y.dtype}")
        break

    device = services.torch.torch_device()
    model = services.torch.fashion.FashionNeuralNetwork().to(device)

    services.console.print_status(f"torch device '{device}' model:")
    print(model)

    loss_fn = torch.nn.CrossEntropyLoss()
    optimizer = torch.optim.SGD(model.parameters(), lr=1e-3)

    services.console.print_status("torch train ...")

    for t in range(epochs):
        print(f"epoch {t+1}\n-------------------------------")
        services.torch.fashion.train(train_dataloader, model, loss_fn, optimizer)
        services.torch.fashion.test(test_dataloader, model, loss_fn)

    output_path =  "./data/fashion.model.pth"
    torch.save(model.state_dict(),output_path)
    services.console.print_ok(f"torch saved model weights to '{output_path}'")

cli.add_command(infer)
cli.add_command(train)

if __name__ == "__main__":
    cli()
